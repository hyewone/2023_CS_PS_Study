# Greedy

# 그리디

그리디 알고리즘(Greedy Algorithm)은 최적화 문제를 해결하는 알고리즘 중 하나로, 각 단계에서 **현재 상황에서 가장 좋아 보이는 선택**을 하는 방식으로 문제를 해결합니다. 이러한 선택을 "탐욕적인 선택"이라고 부르며, 그리디 알고리즘은 이러한 탐욕적인 선택을 통해 전체 문제의 **최적해**를 찾아가려고 합니다.

### 그리디 알고리즘의 특징

1. **로컬 최적해**: 각 단계에서 현재 상황에서 가장 좋은 선택을 합니다. 이 선택은 해당 단계에서는 최적이지만, 전체 문제에 대한 최적해를 보장하지는 않습니다.
2. **간단하고 빠름**: 그리디 알고리즘은 각 단계에서의 선택이 간단하므로, 종종 다른 알고리즘보다 빠르게 동작합니다.
3. **항상 최적해를 보장하지 않음**: 그리디 알고리즘은 특정 문제에 대해 최적해를 찾을 수 있지만, 모든 문제에 대해 최적해를 보장하는 것은 아닙니다.

### 그리디 알고리즘의 예시

1. **거스름돈 문제**: 가장 큰 단위의 동전부터 최대한 사용하여 거스름돈을 줍니다.
2. **분할 가능 배낭 문제**: 단위 무게당 가치가 가장 높은 물건부터 배낭에 넣습니다.
3. **최소 신장 트리의 Kruskal 알고리즘**: 가장 가중치가 낮은 간선부터 선택하여 트리를 구성합니다.

- **그리디 알고리즘을 적용하기 전에 해당 문제가 그리디 알고리즘으로 최적해를 찾을 수 있는지 확인하는 것이 중요함!**
- **왜 이 문제를 그리디 알고리즘을 적용해서 해결할 수 있는지 아는 것이 중요함!**

### 그리디 알고리즘으로 풀 수 있는 문제의 조건

그리디 알고리즘으로 풀 수 있는 문제는 특정 조건을 만족해야 합니다. 이러한 조건은 그리디 알고리즘이 항상 최적의 해를 찾을 수 있도록 보장합니다. 그리디 알고리즘을 적용할 수 있는 문제의 주요 조건은 다음과 같습니다:

1. **탐욕적 선택 속성 (Greedy Choice Property)**:
    - 각 단계에서의 탐욕적 선택이 최종 해답을 구성하는 데에도 유효하다는 것을 의미합니다.
    - 즉, 각 단계에서의 최적의 선택이 전체 문제에 대한 최적의 해답으로 이어진다는 것을 보장해야 합니다.
2. **최적 부분 구조 (Optimal Substructure)**:
    - 문제의 최적해가 그것의 부분 문제들의 최적해로부터 구성될 수 있어야 합니다.
    - 예를 들어, 문제를 여러 개의 작은 문제로 나누었을 때, 작은 문제의 최적의 해를 결합하면 전체 문제의 최적의 해가 되어야 합니다.

이러한 조건들이 만족될 때, 그리디 알고리즘은 문제를 효과적으로 해결할 수 있습니다. 그러나 그리디 알고리즘이 항상 최적의 해를 찾을 수 있는 것은 아니기 때문에, 문제의 특성과 위의 조건들을 잘 분석하여 그리디 알고리즘이 적절한지 판단해야 합니다.

실제로 많은 문제들이 그리디 알고리즘의 조건을 만족하지 않기 때문에, 그리디 알고리즘을 사용하기 전에 해당 문제가 그리디 알고리즘으로 해결될 수 있는지 충분히 검토해야 합니다.

## 관련 문제

- [11047번: 동전 0 (acmicpc.net)](https://www.acmicpc.net/problem/11047)

### 해설

- **목표**
    - 목표 금액을 만들기 위해 필요한 동전 개수의 최솟값 구하기
- **해결**
    - **동전이 배수 관계이기 때문에 그리디 알고리즘을 사용해서 풀 수 있습니다.**
        - **왜냐하면 항상 가치가 높은 동전이 가치가 적은 동전 여러 개를 대체할 수 있기 때문입니다.**
    - 가장 큰 동전부터 시작하여, 목표 금액을 만들 수 있는 최대한의 동전 개수를 계산합니다.
    - **`sum`**을 현재 동전의 값으로 나눈 몫을 **`cnt`**에 더하고, **`sum`**을 현재 동전의 값으로 나눈 나머지로 업데이트합니다. 이 과정을 모든 동전에 대해 반복합니다.
- **예시**:
동전의 종류가 3개이고, 각각의 값이 1, 5, 10이며, 목표 금액이 28인 경우:
    - 10원 동전 2개 (20원)
    - 5원 동전 1개 (5원)
    - 1원 동전 3개 (3원)
    총 6개의 동전이 필요하므로, 결과는 **`6`**이 됩니다.

### 소스코드

```cpp
#include <iostream>
using namespace std;

int main() {
    int n, sum, money[10]{}, cnt = 0;
    cin >> n >> sum;
    for (int i = 0; i < n; i++) {
        cin >> money[i];
    }
    for (int i = n - 1; i >= 0; i--) {
        cnt += (sum / money[i]);
        sum %= money[i];
    }
    cout << cnt;
}
```